#!/bin/bash

trap 'echo >&2 "[!] eureka: got ($?) on line $LINENO: $BASH_COMMAND"' ERR

set -eEuo pipefail

while [[ $# -gt 0 ]]; do
    arg="$1" ; shift
    case $arg in
        (-h|--help)
            HELP=1 ;;
        (-v|--verbose)
            VERBOSE=1 ;;
        (-m|--multi|--multiple)
            MULTI=1 ;;
        (--no-multi|--no-multiple)
            unset MULTI ;;
        (-e|--env|--environ|--environment)
            ENVIRONMENT=$1 ; shift ;;
        (-d|--dump)
            DUMP=1 ;;
        (--no-dump)
            unset DUMP ;;
        (-s|--suggest)
            MAKE_SUGGESTIONS=1 ;;
        (-S|--services?)
            MAKE_SERVICE=1 ;;
        (--no-suggest)
            unset MAKE_SUGGESTIONS ;;
        (-f|--field)
            FIELD=$1 ; shift ;;
        (-*)
            echo >&2 "I don't understand this argument: $arg"
            HELP=1
            ;;
        (*)
            SERVICES+=( "$arg" ) ;;
    esac
done

if [[ -v HELP || ! -v SERVICES ]]; then
    cat >&2 <<EOF
$(basename $0): look up maxar services via eureka

Usage: $(basename $0) [-h|--help] [(-e|--env|--environment) ENV] SERVICE...

General Options: 

-h|--help       This help output.
-s|--suggest    suggest other possible service names when none are found
-e|--env|--environment ENV
                choose the eureka server with this environment from the service
                discovery map (this is not the service environment! try using a
                service url!)

Output Options:

-d|--dump        dump the full eureka JSON response, and halt further processing
-m|--multi       produce output for all matching services
-v|--verbose     output the full JSON objects
-S|--service     output service urls
-f|--field FIELD output the specified JSON field

SERVICE          One or more services to be looked up. may be either a bare
                 service name, or a "service://" url
EOF
    exit 0
fi

[[ -v EUREKA_SERVER_URL && -v SERVICE_DISCOVERY_MAP ]] || . ~/.ssh/P2020

if [[ -v ENVIRONMENT ]]; then
    try_url="$( jq -re --arg env $ENVIRONMENT '.[$env]?' <<< $SERVICE_DISCOVERY_MAP )" \
        && EUREKA_SERVER_URL=$try_url \
        || { echo >&2 "[!] could not match environment '$ENVIRONMENT'" ; true ; }
fi


build_service_url() {
    # we'll read a json payload from stdin
    jq -r '"service://\(.app | ascii_downcase)/\(.metadata.version)/\(.metadata.environment)"'
}

fail() {
    [[ -v MAKE_SUGGESTIONS ]] && make_suggestions
    exit 1
}

make_suggestions() {
    echo >&2 "[!] service not found; perhaps one of these?"
    build_service_url <<< "$original" >&2
}

for service in "${SERVICES[@]}"; do

    if grep -q '^service://' <<< $service ; then
        # in the form of "service://ancillary-image-tracker-backend-v2/1.0/devint-us-east-1/events"
        service_name=$( cut -d/ -f3 <<< $service )
        service_vers=$( cut -d/ -f4 <<< $service )
        service_env=$( cut -d/ -f5 <<< $service )
        service_path=$( cut -d/ -f6- <<< $service )
    else
        # assumed to be a bare service name
        service_name=$service
        service_vers=
        service_env=
        service_path=
    fi

    # hit the eureka server itself, & get json payload for our service name
    payload="$( curl -Ssf -H "Accept: application/json" "$EUREKA_SERVER_URL/eureka/apps/$service_name" )" || {
        echo >&2 "[!] error caught while looking up '$service'"
        exit 1
    }

    # first unwrap
    payload="$( jq -c '.application.instance[]?' <<< "$payload" )"
    # save a copy for finding suggestions
    original="$payload"

    if [[ -v DUMP ]]; then
        jq . <<< $payload
    else
        # turn our version number $(potentially w/ shell wildcards) into a regex, kinda
        service_vers="^$( sed 's/\*/.*/g' <<< $service_vers | sed 's/\./\\./g' )"
        # filter based on that version number
        [[ $service_vers ]] && { payload="$( jq -sce --arg vers "$service_vers" '.[] | select( .metadata.version | try tostring catch "" | test( $vers ))' <<< "$payload" )" || fail ; }
        # clean up our service environment
        [[ $service_env =~ ^(dev|int|devint|reg|prod|ft)$ ]] && service_env="${service_env}-us-east-1"
        # filter by that, if it exists
        [[ $service_env ]] && { payload="$( jq -sce --arg env "$service_env" '.[] | select( .metadata.environment == $env )' <<< "$payload" )" || fail ; }
        # sort instances by version number (highest to lowest)
        payload="$( jq -sce 'sort_by([.metadata.version // "" | split(".")[] | try tonumber catch 0]) | reverse[]' <<< "$payload" )"
        # potentially take the top one
        [[ -v MULTI ]] || payload="$( jq -sce '.[0]' <<< "$payload" )"
        # and display
        if [[ -v VERBOSE ]]; then
            jq -e . <<< "$payload"
        elif [[ -v MAKE_SERVICE ]]; then
            build_service_url <<< "$payload"
        elif [[ -v FIELD ]]; then
            jq -re --arg field "$FIELD" 'getpath($field | split("."))' <<< "$payload"
        else
            jq -re --arg path "$service_path" '"\(.homePageUrl)/\($path)"' <<< "$payload"
        fi
    fi
done
