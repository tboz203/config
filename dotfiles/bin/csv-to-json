#!/usr/bin/env python
"""Translate a Kibana search export CSV to a JSON file."""

import argparse
import csv
import json
import logging
import sys
from enum import Enum
from pathlib import Path
from typing import Optional, Union

logger = logging.getLogger("csv_to_json")


class Output(Enum):
    """Special output directives."""

    # indicates that each output document should be written to its own
    # automaically-named .json file
    AUTOMATIC = "automatic"
    # indicates that all output documents should be written to stdout
    STDOUT = "stdout"


class Outputter:
    """
    A class to manage outputting converted JSON documents.

    This class eases the process of writing one or more JSON documents to
    either stdout, automatically named .json files, or a single aggregate
    .json file.
    """

    def __init__(self, target: Union[Output, str], force: bool, indent: Optional[int]) -> None:
        """
        Initialize a new Outputter.

        :param target: either an `Output` enum member, or a filename.
        :param force: whether to overwrite existing output files.
        :param indent: optional JSON indentation.
        """
        self.target = target
        self.force = force
        self.indent = indent
        self.gathered = {}

    def send(self, data: list[dict], filein: str) -> None:
        """Send a JSON-like document structure to be output."""
        # """
        if isinstance(self.target, str):
            # we're collecting output to be written to a single file
            self.gathered[filein] = data
            return
        serialized = self.serialize(data)
        if self.target is Output.STDOUT:
            sys.stdout.write(serialized)
        elif self.target is Output.AUTOMATIC:
            out_path = Path(filein).with_suffix(".json")
            if out_path.exists() and not self.force:
                logger.error("Refusing to overwrite existing file: %s", out_path)
                return
            out_path.write_text(serialized)
        else:
            raise ValueError(f"what is this: {self.target}")

    def serialize(self, data) -> str:
        """Serialize a JSON-like document structure to text."""
        return json.dumps(data, indent=self.indent) + "\n"

    def finalize(self) -> None:
        """Perform finalizing tasks."""
        if isinstance(self.target, str):
            # we've been collecting data to write to a single file
            out_path = Path(self.target)
            if out_path.exists() and not self.force:
                logger.error("Refusing to overwrite existing file: %s", out_path)
                return
            serialized = self.serialize(self.gathered)
            out_path.write_text(serialized)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        del exc_type, exc_value, traceback
        self.finalize()


def parse_one_csv(text: str) -> list[dict]:
    """Convert a CSV document to a JSON-like document structure."""
    # all this boilerplate for 3 lines of library calls
    lines = text.splitlines(keepends=True)
    reader = csv.DictReader(lines)
    return list(reader)


def parse_args(argv: Optional[list[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument(
        "input",
        metavar="INPUT",
        nargs="*",
        default="StdIn",
        help="CSV file(s) to be read in. '-' may be used to indicate 'stdin'.",
    )

    output_group = parser.add_mutually_exclusive_group()
    output_group.add_argument(
        "--stdout",
        dest="output",
        # using `True` instead of the more accurate `Output.STDOUT` so that
        # the default in the help makes more sense
        default=True,
        action="store_true",
        help="Write one JSON document to STDOUT for each INPUT",
    )
    output_group.add_argument(
        "-o",
        "--output",
        help=(
            "Explicit filename for output. If multiple INPUT are given, the "
            "resulting JSON document is an object, with each key being an input "
            "filename, and each value being its that input's JSON "
            "representation."
        ),
    )
    output_group.add_argument(
        "-O",
        "--auto-output",
        dest="output",
        action="store_const",
        const=Output.AUTOMATIC,
        help="Write one `.json` file for each INPUT. `stdin` is written to `stdin.json`",
    )

    parser.add_argument(
        "-i",
        "--indent",
        nargs="?",
        const=2,
        type=int,
        help="number of spaces of JSON output indentation. `-i` without argument is equivalen to `-i 2`",
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Write to output file(s) even if they already exists. Has no effect when writing to StdOut",
    )

    args = parser.parse_args(argv)

    # translate our printable defaults to their correct values
    if args.input == "StdIn":
        args.input = ["-"]
    if args.output is True:
        args.output = Output.STDOUT

    return args


def main():
    args = parse_args()

    # outputter = Outputter(args.output, args.force, args.indent)
    # for filein in args.input:
    #     if filein == "-":
    #         text = sys.stdin.read()
    #     else:
    #         text = Path(filein).read_text()
    #     output = parse_one_csv(text)
    #     outputter.send(output, filein)
    # outputter.finalize()

    with Outputter(args.output, args.force, args.indent) as outputter:
        for filein in args.input:
            # using `utf-8-sig` encoding to swallow
            text = sys.stdin.read() if filein == "-" else Path(filein).read_text("utf-8-sig")
            output = parse_one_csv(text)
            outputter.send(output, filein)


if __name__ == "__main__":
    main()
