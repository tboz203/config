#!/usr/bin/env python3

import argparse
import itertools
import time
import logging
import logging.config

import requests


LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': ('[%(levelname)8s %(asctime)s %(module)s] %(message)s'),
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'formatter': 'verbose',
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'DEBUG',
    },
}
logging.config.dictConfig(LOGGING_CONFIG)
logger = logging.getLogger(__name__)

requests.packages.urllib3.disable_warnings()


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('url', help='The url to be pinged')
    parser.add_argument('-c', '--count', type=int, default=3,
                        help='The number of pings to send')
    parser.add_argument('-d', '--delay', type=int, default=1,
                        help='Seconds to wait between pings')
    parser.add_argument('-f', '--forever', action='store_true',
                        help='continue sending pings until interrupted.')
    parser.add_argument('-t', '--timeout', type=int, default=10,
                        help='how long to wait on a request before giving up')
    args = parser.parse_args()

    logger.debug('Arguments: %s', args)

    if args.forever:
        # infinite sequence
        counter = itertools.count()
    else:
        counter = range(args.count)

    try:
        for _ in counter:
            try:
                a = time.clock()
                resp = requests.head(args.url, verify=False, timeout=args.timeout)
                b = time.clock()
                logger.info('%.3f -- %s', b - a, resp)
            except requests.exceptions.ReadTimeout:
                logger.info('TIMED OUT')
            except requests.exceptions.ConnectionError:
                logger.warning('NO CONNECT')
            time.sleep(args.delay)
    except KeyboardInterrupt:
        logger.info('caught keyboard interrupt')
        pass


if __name__ == '__main__':
    try:
        main()
    except Exception as exc:
        logger.exception('Caught exception:')
        exit(exc)
